{
	"goals": [
		{
			"task": "Haz que el jugador se mueva hacia la izquierda",
			"code": "function move() {\n\n\t/*** Clases clave para ayudar a Bersara ***/\n\t//                                        //\n\t// Phaser.Sprite                          //\n\t// Phaser.Keyboard                        //\n\t// Phaser.Physics.Arcade                  //\n\t// Phaser.Physics.Arcade.Body             //\n\t//                                        //\n\t/******************************************/\n\n\t/* En this.cursors tenemos un objeto con la información de \n\t   nuestros 4 controles: flecha arriba (up), flecha abajo (down),\n\t   flecha derecha (right), flecha izquierda (down)\n\t   Si queremos saber si alguno de los controles ha sido pulsado\n\t   podemos consultar su propiedad 'isDown' */\n\tif (this.cursors.right.isDown) {\n\t\t/* En el caso de haber pulsado la flecha derecha nos moveremos \n\t\t   en el sentido positivo del eje X, y por tanto nuestra \n\t\t   velocidad en la X tiene que ser positiva\n\t\t   En 'this.walkSpeed' tenemos la velocidad que necesitamos \n\t\t   para caminar */\n\t\tthis.sprite.body.velocity.x = this.walkSpeed;\n\n\t\t/* Antes de asignar la animación de andar hacia la derecha \n\t\t   tenemos que comprobar que estamos en el suelo. Para ello\n\t\t   nos fijaremos en las propiedad 'touching' de body */\n\t\tif (this.sprite.body.onFloor() || this.sprite.body.touching.down) {\n\t\t\t/* Para ejecutar una animación usamos la función 'play'\n\t\t\t   de 'sprite'. En este caso ejecutaremos \n\t\t\t   'player_animation_moveRight' */\n\t\t\tthis.sprite.play('player_animation_moveRight', 5, true);\n\t\t}\n\n\t\t/* Para cambiar el sentido en el que mira Bersara nos \n\t\t   fijaremos en nuestra dirección. Tenemos dos posibles \n\t\t   direcciones: 'State.LOOKINGLEFT' y 'State.LOOKINGRIGHT' */\n\t\tif (this.direction == State.LOOKINGLEFT) {\n\t\t\t/* Sólo cambiamos su sentido si estaba mirando en sentido\n\t\t\t   contrario */\n\t\t\tthis.direction = State.LOOKINGRIGHT;\n\t\t}\n\t}\n\n\n\n\t/* Ahora te toca a ti!! Lo primero es comprobar si se ha pulsado\n\t   la flecha izquierda (this.cursors.left) */\n\n\n\t/* Si es así tenemos que ir en el sentido negativo del eje X, por \n\t   lo que asignaremos '-walkSpeed' como nueva velocidad */\n\n\n\t/* Comprobamos si Bersara esta en el suelo, igual que hemos hecho \n\t   antes, y si es así cambiamos su animación. Esta vez toca \n\t   'player_animations_moveLeft' */\n\n\n\t/* Y por último tenemos que cambiar el sentido de Bersara en caso\n\t   de que este mirando en sentido contrario */\n\n\n\n\t/* Si no se ha pulsado nada no moveremos a Bersara. En este caso \n\t   lo único que tenemos que hacer es asegurarnos de que se\n\t   ejecuta la animación correcta, dependiendo de a donde este \n\t   mirando Bersara */\n\telse {\n\t\tif (this.direction == State.LOOKINGLEFT) {\n\t\t\tthis.sprite.play('player_animation_standUpLeft');\n\t\t}\n\t\telse if (this.direction == State.LOOKINGRIGHT) {\n\t\t\tthis.sprite.play('player_animation_standUpRight');\n\t\t}\n\n\t\t/* Y ponemos su velocidad a 0 ya que no tiene que moverse */\n\t\tthis.sprite.body.velocity.x = 0;\n\t}\n}\n\n",
			"target": "player.move",
			"range1": [0,0,43,0],
			"range2": [64,0,80,0],
			"test": "testMoveLeft(text)",
			"line": 49
		},
		{
			"task": "Haz que el jugador pueda saltar",
			"code": "function jump() {\n\n\t//\tClases clave para ayudar a Bersara \n\t//\n\t//\tPhaser.Sprite\n\t//\tPhaser.Keyboard\n\t//\tPhaser.Physics.Arcade\n\t//\tPhaser.Physics.Arcade.Body\n\t//\n\t//\tPistas:\n\t//\tState: LOOKINGLEFT y LOOKINGRIGHT\n\t//\tAnimaciones: player_animation_jumpLeft y player_animation_jumpRight\n\t//\n\t//\t¡Buena Suerte! \n\n\n\n\n\t// Para poder saltar tenemos que comprobar primero que hemos pulsado \n\t// la flecha hacia arriba, que nuestro jugador esta en el suelo y que no estamos ya saltando\n\tif (this.cursors.up.isDown && (this.sprite.body.onFloor() || this.sprite.body.touching.down) && this.game.time.now > this.jumpTimer) {\n\n\t// Si estamos mirando hacia la izquierda ponemos la animación que \n\t// salta hacia la izquierda\n\n\t// Y si estamos mirando hacia la derecha la de saltar hacia la derecha\n\n\t// Por último cambiamos su velocidad vertical que es 0 a jumpSpeed\n\n\n\t\tthis.jumpTimer = this.game.time.now + 750;\n\t}\n}\n",
			"target": "player.jump",
			"range1": [0,0,17, 0],
			"range2": [26,0,30,0],
			"test": "testJump(text)",
			"line": 21
		},
		{
			"task": "Haz que los enemigos caigan al agua y mueran",
			"code": "function snailsMove(enemy) {\n\n\t// Si el caracol choca con algo por la izquierda cambia su sentido\n\tif (enemy.body.blocked.left || enemy.body.touching.left) {\n\t\tenemy.direction = State.LOOKINGRIGHT;\n\t}\n\t// E igualmente en el caso contrario, si choca con algo por la \n\t// derecha cambia de sentido\n\telse if (enemy.body.blocked.right || enemy.body.touching.right) {\n\t\tenemy.direction = State.LOOKINGLEFT;\n\t}\n\n\t// Si el caracol esta mirando hacia la izquierda su velocidad sera \n\t// negativa y su escala positiva\n\n\t// En cambio si esta mirando hacia la derecha su velocidad sera \n\t// positiva y su escala negativa\n\n\t// También debemos programar que se muera cuando caiga al agua y \n\t// alcance cierta profundidad. Para ello comprobaremos si su 'y' es \n\t// mayor que 980, y si es así lo mataremos\n\n\n}\n",
			"target": "snailsMove",
			"range1": [0,0,11,0],
			"range2": [23,0,24,0],
			"test": "testMoveSnails(text)",
			"line": 15
		},
		{
			"task": "Haz que los enemigos mueran al saltar encima",
			"code": "function upCollision(player, enemy) {\n\n\t// Comprobamos si hemos tocado al enemigo por arriba\n\n\t// Si es asi le matamos y saltamos\n\n\t// Para saltar haremos algo muy parecido a lo que hicimos en la \n\t// funcion Jump(), cambiamos su velocidad vertical y actualizamos \n\t// el jumpTime\n\n\n\t// Y si hemos tocado al enemigo por otro lado entonces moriremos nosotros\n\telse {\n\t\tthis.die();\n\t}\n}\n",
			"target": "player.upCollision",
			"range1": [0,0,3,0],
			"range2": [11,0,16,0],
			"test": "testJumpOverEnemy(text)",
			"line": 4
		},
		{
			"task": "Mostrar Score en el Hud",
			"code": "function createScore(){\n\n\t// Creamos el texto en la posición (16, 16)\n\t// Te aconsejamos que pongas como tamaño a la fuente 32px \n\t// y color blanco\n\n\t// Fijamos el texto a la camara\n\n\n\n}\n",
			"target": "hud.createScore",
			"range1": [0,0,1,0],
			"range2": [10,0,11,0],
			"test": "testCreateScore(text)",
			"line": 6
		},
		{
			"task": "Haz que el jugador pueda recoger monedas",
			"code": "function pickCoin(player, coin) {\n\n\t// Eliminamos la moneda del juego\n\n\t// Actualizamos la puntuación en el hud y actualizamos el texto \n\t// que muestra la puntuación\n\n\n}\n",
			"target": "player.pickCoin",
			"range1": [0,0,2,0],
			"range2": [8,0,9,0],
			"test": "testPickCoins(text)",
			"line": "4"
		},
		{
			"task": "Crea la puerta para salir del nivel",
			"code": "function createDoors(game) {\n\n\t// Lo primero es dar cuerpo a la puerta con la propiedad 'enableBody'\n\n\n\t// Y despues obtenemos los objetos 'puerta' de nuestro mapa\n\t// En este caso sólo contamos con una puerta\n\tlevel.map.createFromObjects('Object Layer 1', tiledId.doorId , 'door-image', 0 , true, false, this.doors);\n}\n",
			"target": "createDoors",
			"range1": [0,0,3,0],
			"range2": [5,0,9,0],
			"test": "testCreateDoor(text)",
			"line": 4
		}
	]
}

