{
	"goals": [
		{
			"task": "Haz que el jugador se mueva hacia la izquierda",
			"code": "function move() {\n\n\t/*** Clases clave para ayudar a Bersara ***/\n\t//                                        //\n\t// Phaser.Sprite                          //\n\t// Phaser.Keyboard                        //\n\t// Phaser.Physics.Arcade                  //\n\t// Phaser.Physics.Arcade.Body             //\n\t//                                        //\n\t/******************************************/\n\n\t/* En this.cursors tenemos un objeto con la información de \n\t   nuestros 4 controles: flecha arriba (up), flecha abajo (down),\n\t   flecha derecha (right), flecha izquierda (down)\n\t   Si queremos saber si alguno de los controles ha sido pulsado\n\t   podemos consultar su propiedad 'isDown' */\n\tif (this.cursors.right.isDown) {\n\t\t/* En el caso de haber pulsado la flecha derecha nos moveremos \n\t\t   en el sentido positivo del eje X, y por tanto nuestra \n\t\t   velocidad en la X tiene que ser positiva\n\t\t   En 'this.walkSpeed' tenemos la velocidad que necesitamos \n\t\t   para caminar */\n\t\tthis.sprite.body.velocity.x = this.walkSpeed;\n\n\t\t/* Antes de asignar la animación de andar hacia la derecha \n\t\t   tenemos que comprobar que estamos en el suelo. Para ello\n\t\t   nos fijaremos en las propiedad 'touching' de body */\n\t\tif (this.sprite.body.onFloor() || this.sprite.body.touching.down) {\n\t\t\t/* Para ejecutar una animación usamos la función 'play'\n\t\t\t   de 'sprite'. En este caso ejecutaremos \n\t\t\t   'player_animation_moveRight' */\n\t\t\tthis.sprite.play('player_animation_moveRight', 5, true);\n\t\t}\n\n\t\t/* Para cambiar el sentido en el que mira Bersara nos \n\t\t   fijaremos en nuestra dirección. Tenemos dos posibles \n\t\t   direcciones: 'State.LOOKINGLEFT' y 'State.LOOKINGRIGHT' */\n\t\tif (this.direction == State.LOOKINGLEFT) {\n\t\t\t/* Solo cambiamos su sentido si estaba mirando en sentido\n\t\t\t   contrario */\n\t\t\tthis.direction = State.LOOKINGRIGHT;\n\t\t}\n\t}\n\n\n\n\t/* Ahora te toca a ti!! Lo primero es comprobar si se ha pulsado\n\t   la flecha izquierda (this.cursors.left) */\n\n\n\t/* Si es así tenemos que ir en el sentido negativo del eje X, por \n\t   lo que asignaremos '-walkSpeed' como nueva velocidad */\n\n\n\t/* Comprobamos si Bersara esta en el suelo, igual que hemos hecho \n\t   antes, y si es así cambiamos su animación. Esta vez toca \n\t   'player_animations_moveLeft' */\n\n\n\t/* Y por último tenemos que cambiar el sentido de Bersara en caso\n\t   de que este mirando en sentido contrario */\n\n\n\n\t/* Si no se ha pulsado nada no moveremos a Bersara. En este caso \n\t   lo único que tenemos que hacer es asegurarnos de que se\n\t   ejecuta la animación correcta, dependiendo de a donde este \n\t   mirando Bersara */\n\telse {\n\t\tif (this.direction == State.LOOKINGLEFT) {\n\t\t\tthis.sprite.play('player_animation_standUpLeft');\n\t\t}\n\t\telse if (this.direction == State.LOOKINGRIGHT) {\n\t\t\tthis.sprite.play('player_animation_standUpRight');\n\t\t}\n\n\t\t/* Y ponemos su velocidad a 0 ya que no tiene que moverse */\n\t\tthis.sprite.body.velocity.x = 0;\n\t}\n}\n\n",
			"target": "player.move",
			"range1": [0,0,43,0],
			"range2": [64,0,80,0],
			"test": "testMoveLeft(text)",
			"line": 49
		},
		{
			"task": "Haz que el jugador pueda saltar",
			"code": "function jump() {\n\n\t/*** Clases clave para ayudar a Bersara ***/\n\t//                                        //\n\t// Phaser.Sprite                          //\n\t// Phaser.Keyboard                        //\n\t// Phaser.Physics.Arcade                  //\n\t// Phaser.Physics.Arcade.Body             //\n\t//                                        //\n\t/******************************************/\n\n\t/* Para saltar tenemos que comprobar tres cosas:\n\t   -> Que hayamos pulsado la flecha arriba (this.cursors.up).\n\t   -> Que estemos tocando el suelo. Esto lo podemos comprobar\n\t      bien con la funcion 'onFloor' de Body o con la propiedad\n\t      'touching.down' del sprite.\n\t   -> Que no estemos ya saltando. Esto lo comprobamos con un\n\t      timer (this.jumpTimer) */\n\tif (this.cursors.up.isDown && (this.sprite.body.onFloor() || this.sprite.body.touching.down) && this.game.time.now > this.jumpTimer) {\n\n\n\t\t/* Al igual que en la función 'move' tenemos que cambiar \n\t\t   la animación, y depende de hacia donde mire Bersara. \n\t\t   Si esta mirando hacia la izquierda ejecutaremos \n\t\t   'player_animation_jumpLeft', y si esta mirando hacia \n\t\t   la derecha 'player_animation_jumpRight' */\n\n\n\t\t/* Y por supuesto para poder saltar tenemos que cambiar \n\t\t   su velocidad en la Y, ya que tenemos que movernos en el \n\t\t   eje Y. La velocidad de salto esta guardada en \n\t\t   'this.walkSpeed'*/\n\n\n\n\t\t/* Actualizamos el timer del salto. No podremos saltar \n\t\t   hasta dentro de 750 ms */\n\t\tthis.jumpTimer = this.game.time.now + 750;\n\t}\n}\n\n",
			"target": "player.jump",
			"range1": [0,0,20, 0],
			"range2": [35,0,40,0],
			"test": "testJump(text)",
			"line": 27
		},
		{
			"task": "Haz que los enemigos caigan al agua y mueran",
			"code": "function snailsMove() {\n\n\t/*** Clases clave para ayudar a Bersara ***/\n\t//                                        //\n\t// Phaser.Group                           //\n\t// Phaser.Physics.Arcade                  //\n\t// Phaser.Physics.Arcade.Body             //\n\t//                                        //\n\t/******************************************/\n\n\t/* Cuando el enemigo choca contra algo se da la vuelta \n\t\ty cambia de sentido. Para saber si se ha chocado \n\t\tpodemos usar las propiedades 'blocked' o 'touching'\n\t\tde Body */\n\tif (enemy.body.blocked.left || enemy.body.touching.left) {\n\t\tenemy.direction = State.LOOKINGLEFT;\n\t}\n\t\telse if (enemy.body.blocked.right || enemy.body.touching.right) {\n\t\tenemy.direction = State.LOOKINGLEFT;\n\t}\n\n\t/* Lo siguiente es cambiar su velocidad según la dirección\n\t\ta la que este mirando, al igual que hicimos con Bersara.\n\t\tTambién tendremos que cambiar su escala. Con la escala \n\t\tpodemos dar la vuelta a nuestros sprites, como si se viesen\n\t\treflejados en un espejo. \n\t\tPara nuestros enemigos sólo tenemos en el spritesheet\n\t\t animaciones para andar hacia la izquierda, así que cambiaremos\n\t\tla escala cuando ande hacia la derecha y así no nos harán \n\t\tfalta más animaciones.\n\t\tPor tanto, si vamos a movernos hacia la izquierda tendremos\n\t\tque asignar una velocidad negativa (-enemy.walkSpeed) y una\n\t\tescala positiva (enemy.scale = 1) */\n\n\n\t/* Si vamos a movernos hacia la derecha tendremos que asignar una\n\t\tvelocidad positiva (enemy.walkSpeed) y una escala negativa \n\t\t(enemy.scale = -1) para darle la vuelta a nuestro sprite */\n\n\n\n\t/* Por último, y no por ello menos importante, tenemos que matar\n\t\ta los caracoles si llegan a cierta profundidad. Así que si la \n\t\t'y' es mayor o igual que 980 tendremos que matarles con el \n\t\tmétodo 'kill()' */\n\n\n\n}\n\n",
			"target": "snailsMove",
			"range1": [0,0,11,0],
			"range2": [23,0,24,0],
			"test": "testMoveSnails(text)",
			"line": 15
		},
		{
			"task": "Haz que los enemigos mueran al saltar encima",
			"code": "function upCollision(player, enemy) {\n\n\t// Comprobamos si hemos tocado al enemigo por arriba\n\n\t// Si es asi le matamos y saltamos\n\n\t// Para saltar haremos algo muy parecido a lo que hicimos en la \n\t// funcion Jump(), cambiamos su velocidad vertical y actualizamos \n\t// el jumpTime\n\n\n\t// Y si hemos tocado al enemigo por otro lado entonces moriremos nosotros\n\telse {\n\t\tthis.die();\n\t}\n}\n",
			"target": "player.upCollision",
			"range1": [0,0,3,0],
			"range2": [11,0,16,0],
			"test": "testJumpOverEnemy(text)",
			"line": 4
		},
		{
			"task": "Mostrar Score en el Hud",
			"code": "function createScore(){\n\n\t// Creamos el texto en la posición (16, 16)\n\t// Te aconsejamos que pongas como tamaño a la fuente 32px \n\t// y color blanco\n\n\t// Fijamos el texto a la camara\n\n\n\n}\n",
			"target": "hud.createScore",
			"range1": [0,0,1,0],
			"range2": [10,0,11,0],
			"test": "testCreateScore(text)",
			"line": 6
		},
		{
			"task": "Haz que el jugador pueda recoger monedas",
			"code": "function pickCoin(player, coin) {\n\n\t// Eliminamos la moneda del juego\n\n\t// Actualizamos la puntuación en el hud y actualizamos el texto \n\t// que muestra la puntuación\n\n\n}\n",
			"target": "player.pickCoin",
			"range1": [0,0,2,0],
			"range2": [8,0,9,0],
			"test": "testPickCoins(text)",
			"line": "4"
		},
		{
			"task": "Crea la puerta para salir del nivel",
			"code": "function createDoors(game) {\n\n\t// Lo primero es dar cuerpo a la puerta con la propiedad 'enableBody'\n\n\n\t// Y despues obtenemos los objetos 'puerta' de nuestro mapa\n\t// En este caso sólo contamos con una puerta\n\tlevel.map.createFromObjects('Object Layer 1', tiledId.doorId , 'door-image', 0 , true, false, this.doors);\n}\n",
			"target": "createDoors",
			"range1": [0,0,3,0],
			"range2": [5,0,9,0],
			"test": "testCreateDoor(text)",
			"line": 4
		}
	]
}

